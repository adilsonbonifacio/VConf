import sys
from copy import deepcopy
import logging
from iovpts import IOVPTS, read_iovpts_file
from vpa import VPA, read_vpa_file
from contracted import Contracted
from transfmodel import TransfModel
from compmodel import CompModel
from intersecmodel import IntersecModel
import intersecmodel as simplify
from vpa2iovpts import VPA2IOVPTS
from nonblocking import NonBlocking
import nonblocking as save_nonblocking
from unionmodel import UnionModel
import unionmodel as simplify_union
from renaming import Renaming
from balancedRunChecker import BalancedRunChecker
import streamlit as st
import io  # Import to handle in-memory binary files
import time 

# Configuração de logging
logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s  \n%(filename)s - %(funcName)s\n',
    datefmt='%Y-%m-%d %H:%M:%S',
    level=logging.INFO
)

# Título e subtítulo no Streamlit
#st.title("Visual Conformance Checking Tool")
st.title("Conformance Checking Tool")
st.subheader("Language-based Visual Conformance Relation")
#st.subheader("Verificação de Conformidade")

# # Seção de Ajuda
# with st.expander("Help", expanded=False):
#     st.markdown("""
#     **Como usar esta ferramenta:**
    
#     1. **Upload dos Arquivos:** Carregue dois arquivos em formato `.txt`. Um deve conter a especificação e o outro a implementação.
#     2. **Verificação de Conformidade:** Após o upload dos arquivos, clique no botão "Verificar Conformidade". A ferramenta irá analisar a conformidade ioco-like.
#     3. **Resultado:** O resultado da verificação será exibido na tela, juntamente com detalhes do processo.
#     4. **Download dos Detalhes:** Você pode baixar um arquivo contendo todos os detalhes da verificação clicando no botão "Baixar Detalhamento Completo".
    
#     **Observações:**
#     - Ambos os arquivos são necessários para realizar a verificação.
#     - Certifique-se de que os arquivos estão formatados corretamente. Eles devem seguir esta estrutura:
#       - **Linha 1:** Ações CALL (empilham símbolos).
#       - **Linha 2:** Ações RETURN (desempilham símbolos).
#       - **Linha 3:** Ações INTERNAL (não afetam a pilha).
#       - **Linha 4:** Ações INPUT (eventos do ambiente externo).
#       - **Linha 5:** Ações OUTPUT (eventos gerados pelo sistema).
#       - **Linha 6:** Símbolos de pilha, incluindo `@` (transições internas) e `*` (estado de pilha vazia).
#       - **Linhas 7:** Estados do modelo.
#       - **Linhas 8 até x:** Transições do modelo no formato: estado_origem,ação,símbolo_de_pilha,estado_destino
#       - **Linhas (x+1):** Símbolo # que indica o fim da descrição de transições.
#       - **Linhas (x+2):** Estado inicial do modelo.
#       - **Linhas (x+3):** Símbolo - para indicar o fim da descrição do modelo. 

#     Lembre-se de que cada linha deve ser formatada corretamente, sem símbolos adicionais no final, e uma linha em branco deve ser deixada para conjuntos vazios.
#     Sempre quando houver múltiplos itens (símbolos, estados, ações, etc) por linha separe por vírgula sem espaço.
#     """)

with st.expander("Help", expanded=False):
    st.markdown("""
**How ​​to use this tool:**

1. **Upload Files:** Upload two files in `.txt` format. One should contain the specification, the implementation, and the desirable and undesirable behaviors.
2. **Conformance Check:** After uploading the files, click on the "Check Conformance" button. The tool will analyze the vconf relation.
3. **Result:** The result of the check will be displayed on the screen, along with details of the process.
4. **Download Details:** You can download a file containing all the check details by clicking on the "Download Full Details" button.

**Notes:** - The description files are required to perform the check.
- Make sure the files are formatted correctly. They should follow this structure:
- **Line 1:** CALL actions (stack symbols).
- **Line 2:** RETURN actions (unstack symbols).
- **Line 3:** INTERNAL actions (do not affect the stack).
- **Line 4:** INPUT actions (events from the external environment).
- **Line 5:** OUTPUT actions (events generated by the system).
- **Line 6:** Stack symbols, including `@` (internal transitions) and `*` (empty stack state).
- **Lines 7:** Model states.
- **Lines 8 to x:** Model transitions in the format: source_state,action,stack_symbol,destination_state
- **Lines (x+1):** Symbol # indicating the end of the transition description.
- **Lines (x+2):** Initial state of the model.
- **Lines (x+3):** Symbol - to indicate the end of the model description.

Remember that each line must be formatted correctly, with no additional symbols at the end, and a blank line must be left for empty sets.
Whenever there are multiple items (symbols, states, actions, etc.) per line, separate them with a comma without a space.
""")
    
# Instruções para o usuário
st.markdown("Please upload the specification and implementation files (IOVPTS) as well as the desirable and undesirable behaviors (VPA) in `.txt` format.")

# Upload dos arquivos
specificationFile = st.file_uploader("Choose the specification file", type=['txt'], key="file1")
implementationFile = st.file_uploader("Choose the implementation file", type=['txt'], key="file2")
desirableFile = st.file_uploader("Choose the VPA file for the desirable language.", type=['txt'], key="file3")
undesirableFile = st.file_uploader("Choose the VPA file for the undesirable language.", type=['txt'], key="file4")

if specificationFile:
    st.success(f"Loaded specification: {specificationFile.name}")
if implementationFile:
    st.success(f"Loaded Implementation: {implementationFile.name}")
if desirableFile:
    st.success(f"Loaded desirable language: {desirableFile.name}")
if undesirableFile:
    st.success(f"Loaded undesirable language: {undesirableFile.name}")



if st.button("Checking Visual Conformance"):
    if not specificationFile or not implementationFile or not desirableFile or not undesirableFile:
        st.error("Please upload both specification and implementation files (IOVPTS), as well as desirable and undesirable behaviors (VPA) files, in `.txt` format.")
    else:
        with st.spinner("Processando arquivos..."):
            # tempo de processamento
            tempo_inicio = time.perf_counter()
            
            # Armazenar as saídas detalhadas
            details = []

            # Criando os modelos IOVPTS da especificação e da implementação
            specificationIOVPTS = IOVPTS()
            specificationIOVPTS = read_iovpts_file(specificationFile)
            implementationIOVPTS = IOVPTS()
            implementationIOVPTS = read_iovpts_file(implementationFile)

            # print("------------")
            # print("Stacks")
            # print("         ")
            # print(specificationIOVPTS.stack_symbols)
            # print("------------")

            specificationPath = specificationFile.name
            implementationPath = implementationFile.name

            # Criando os VPAs para D e F 
            desirableVPA = VPA()
            desirableVPA = read_vpa_file(desirableFile)
            undesirableVPA = VPA()
            undesirableVPA = read_vpa_file(undesirableFile)

            desirablePath = desirableFile.name
            undesirablePath = undesirableFile.name

            # Logging de informações iniciais
            st.info(f"Testing the IUT described in the {implementationPath} file against the specification (SPEC) in the {specificationPath} file using the desirable and undesirable languages ​​from the {desirablePath} and {undesirablePath} files.\n")
            details.append(f"Testing the IUT described in the {implementationPath} file against the specification (SPEC) in the {specificationPath} file using the desirable and undesirable languages ​​from the {desirablePath} and {undesirablePath} files.\n")
            details.append(f"\nIOVPTS specification:")
            specificationIOVPTS.save_iovpts_info_to_list(details)
            details.append(f"\nIOVPTS implementation:")
            implementationIOVPTS.save_iovpts_info_to_list(details)
            details.append(f"\nVPA for desirable language:")
            desirableVPA.save_vpa_info_to_list(details)
            details.append(f"\nVPA for undesirable language:")
            undesirableVPA.save_vpa_info_to_list(details)

#            Transformando a especificação IOVPTS em contracted

            contracted1 = Contracted(specificationIOVPTS)
            #prods1, nok1, ok1 = getallprods(states1, trans1, push1, pop1, ints1)
            prods1, nok1, ok1 = contracted1.getallprods()
            delta1 = contracted1.genterminals(prods1)
            #okleft1 = contracted.leftmost(delta1)
            okleft1 = contracted1.leftmost(prods1,delta1)
            okpairs1 = contracted1.usefulpairs(okleft1)
            oktrans1,okstates1,okfinals1 = contracted1.usefultrans(contracted1.trans, okpairs1)
            iovpts_contracted1 = contracted1.save_iovpts_contracted()
            details.append(f"\nThe IOVPTS specification is now contracted:\n")
            contracted1.save_contracted_info_to_list(details)

#            Transformando o IOVPTS contracted em VPA 

            transfmodel1 = TransfModel(iovpts_contracted1)
            #transfmodel = transfmodel.iovptstovpa()
            vpa_transfmodel1 = transfmodel1.save_vpa_contracted(specificationIOVPTS)
            details.append(f"\nThe specification is now a VPA from the contracted IOVPTS:\n")
            transfmodel1.save_vpa_from_iovpts_to_list(details)

#            Construção do complemento de S (comp-otr(S)) 

            compmodel_S  = CompModel(vpa_transfmodel1,specificationIOVPTS)
            compstates1, comptrans1, compfinals1 = compmodel_S.compute_complement()
            compmodel1 = compmodel_S.save_comp_model()
            details.append(f"\nNow we obtain the VPA that accepts the complementation of S (comp-otr(S))):\n")
            compmodel_S.save_compmodel_info_to_list(details)
            
#            Construção da intersecção entre o VPA de D e o complemento de otr(S)

            intersecmodel1 = IntersecModel(compmodel1, desirableVPA)
            #intersecpu1, intersecpo1, intersecinte1, intersecstates1, intersecfinals1, intersectrans1, intersecstacks1 = intersecmodel.compute_intersec()
            details.append(f"\nNow we obtain the VPA that accepts the intersection of D and comp-otr(S):\n")
            intersecmodel1.compute_intersec()
            intersecmodel1.save_intersec_info_to_list(details)

#            Simplificação do modelo resultante da intersecção de D e comp-otr(S)

            iniciais1, estados1, finais1 = simplify.compute_estados(intersecmodel1, compmodel1, desirableVPA)
            pilha1 = simplify.compute_pilha(intersecmodel1)
            novosiniciais1, novosestados1, novosfinais1, transicoes1, str_iniciais1, str_estados1, str_finais1, str_pilha1 = simplify.compute_transicoes(intersecmodel1, iniciais1,estados1, pilha1, finais1)
            vpa_simplify1 = simplify.save_intersec_vpa(intersecmodel1,str_iniciais1, str_estados1,transicoes1,str_finais1,str_pilha1)
            simplify.save_dictionaries_info_to_list(iniciais1, estados1, str_estados1, finais1, str_finais1, pilha1, str_pilha1, transicoes1, details)

#            Obtendo o VPA contracted para a intersecção de D e comp-otr(S)
            intersecmodel1_iovpts = VPA2IOVPTS(vpa_simplify1,iovpts_contracted1)

#            Now we get a contracted VPA for D cap comp-otr(S).
#            Transformando o VPA da intesercção entre D e o complemento de S em contracted

            if intersecmodel1_iovpts.transitions == []:
                Dcap_S = False
            else: 
                Dcap_S = True 
                contracted2 = Contracted(intersecmodel1_iovpts)
                prods2, nok2, ok2 = contracted2.getallprods()
                delta2 = contracted2.genterminals(prods2)
                #okleft1 = contracted.leftmost(delta1)
                okleft2 = contracted2.leftmost(prods2,delta2)
                okpairs2 = contracted2.usefulpairs(okleft2)
                oktrans2,okstates2, okfinals2 = contracted2.usefultrans(contracted2.trans, okpairs2)
                # Logging Contracted Model
                vpa_contracted2 = contracted2.save_iovpts_contracted()
                #vpa_contracted2.initial_state = vpa_simplify1.initial_state
                details.append(f"\nThe simplified and contracted VPA for intersection of D and comp-otr(S):\n")
                contracted2.save_contracted_info_to_list(details)

#            Construção da intersecção entre o VPA de F e otr(S)
#            Obtaining the intersection between the models for F and otr(S).

            intersecmodel2 = IntersecModel(vpa_transfmodel1, undesirableVPA)
            intersecmodel2.compute_intersec()
            details.append(f"\nNow we obtain the VPA that accepts the intersection of F and otr(S):\n")
            intersecmodel2.save_intersec_info_to_list(details)

#            Simplificação do modelo resultante da intersecção de F e otr(S)

            iniciais2, estados2, finais2 = simplify.compute_estados(intersecmodel2, vpa_transfmodel1, undesirableVPA)
            pilha2 = simplify.compute_pilha(intersecmodel2)
            novosiniciais2, novosestados2, novosfinais2, transicoes2, str_iniciais2, str_estados2, str_finais2, str_pilha2 = simplify.compute_transicoes(intersecmodel2, iniciais2, estados2, pilha2, finais2)
            #if novosestados2 != [] and transicoes2 != []:
            vpa_simplify2 = simplify.save_intersec_vpa(intersecmodel2,str_iniciais2,str_estados2,transicoes2,str_finais2,str_pilha2)
            simplify.save_dictionaries_info_to_list(iniciais2,estados2,str_estados2, finais2, str_finais2, pilha2, str_pilha2, transicoes2, details)


#            Obtendo o VPA contracted para a intersecção do VPA de F e otr(S)
            intersecmodel2_iovpts = VPA2IOVPTS(vpa_simplify2,iovpts_contracted1)

            # print("Ver parametros")
            # print(intersecmodel2_iovpts.states)
            # print("-------------")
            # print(intersecmodel2_iovpts.stack_symbols)
            # print("-------------")
            # print(intersecmodel2_iovpts.transitions)
            # print("-------------")
            # print("Fim  parametros") 

#            Now we get a contracted VPA for F cap otr(S).
#            Transformando o VPA da intesercção entre F e S em contracted

            if intersecmodel2_iovpts.transitions == []:
                FcapS = False
            else: 
                FcapS = True 
                contracted3 = Contracted(intersecmodel2_iovpts)
                prods3, nok3, ok3 = contracted3.getallprods()
                delta3 = contracted3.genterminals(prods3)
                okleft3 = contracted3.leftmost(prods3,delta3)
                okpairs3 = contracted3.usefulpairs(okleft3)
                oktrans3,okstates3,okfinals3 = contracted3.usefultrans(contracted3.trans, okpairs3)
                vpa_contracted3 = contracted3.save_iovpts_contracted()
                details.append(f"\nThe simplified and contracted VPA for intersection of F and otr(S):\n")
                contracted3.save_contracted_info_to_list(details)


#               Até aqui temos que o vpa_contracted2 é D cap comp-otr(S) 
#               e que o vpa_contracted3 é F cap otr(S)

#               Obtaining T =  (D cap comp-otr(S)) cup (F cap otr(S))
#               Construção da união entre os VPAs de (D cap comp-otr(S)) e (F cap otr(S))

#               Primeiramente obtemos os modelos Non Blocking para os dois VPAs

            if Dcap_S:
                nonblocking1 = NonBlocking(vpa_contracted2)
                ninitial_state1, nstates1, nfinals1, ntrans1, nstacks1 = nonblocking1.nonblocking()
                vpa_nonblocking1 = save_nonblocking.save_nonblocking_vpa(nonblocking1, ninitial_state1, nstates1,ntrans1,nfinals1,nstacks1)

            if FcapS: 
                nonblocking2 = NonBlocking(vpa_contracted3)
                ninitial_state2, nstates2, nfinals2, ntrans2, nstacks2 = nonblocking2.nonblocking()
                vpa_nonblocking2 = save_nonblocking.save_nonblocking_vpa(nonblocking2, ninitial_state2, nstates2,ntrans2,nfinals2,nstacks2)

#               Agora obtemos a união T =  (D cap comp-otr(S)) cup (F cap otr(S))

            vazio = False
            if FcapS and Dcap_S: 
                unionmodel = UnionModel(vpa_nonblocking1, vpa_nonblocking2)
                unionmodel.compute_union()
                details.append(f"\nNow we obtain the VPA that accepts the union of (D cap comp-otr(S) and (F cap otr(S)):\n")

#            Simplificação do modelo resultante da união

                iniciais_u,estados_u, finais_u = simplify_union.compute_estados(unionmodel, vpa_nonblocking1, vpa_nonblocking2)
                pilha_u = simplify.compute_pilha(unionmodel)
                novosiniciais_u,novosestados_u, novosfinais_u, transicoes_u, str_iniciais_u, str_estados_u, str_finais_u, str_pilha_u = simplify_union.compute_transicoes(unionmodel, iniciais_u,estados_u, pilha_u, finais_u)
                vpa_simplify_union = simplify_union.save_union_vpa(unionmodel,str_iniciais_u,str_estados_u,transicoes_u,str_finais_u,str_pilha_u)
                simplify_union.save_dictionaries_info_to_list(iniciais_u, estados_u, str_estados_u, finais_u, str_finais_u, pilha_u, str_pilha_u, transicoes_u, details)


#           Obtendo o VPA contracted da união
                unionmodel_iovpts = VPA2IOVPTS(vpa_simplify_union,iovpts_contracted1)

#            Now we get a contracted VPA for the union
#            Transformando o VPA da união em contracted

                contracted4 = Contracted(unionmodel_iovpts)
                prods4, nok4, ok4 = contracted4.getallprods()
                delta4 = contracted4.genterminals(prods4)
                okleft4 = contracted4.leftmost(prods4,delta4)
                okpairs4 = contracted4.usefulpairs(okleft4)
                oktrans4,okstates4,okfinals4 = contracted4.usefultrans(contracted4.trans, okpairs4)
                vpa_contracted4 = contracted4.save_iovpts_contracted()
                details.append(f"\nThe simplified and contracted VPA for union:\n")
                contracted4.save_contracted_info_to_list(details)

#            O VPA vpa_contracted4 é o resultado da união 

            elif Dcap_S: 
                vpa_contracted4 =vpa_nonblocking1
            elif FcapS: 
                vpa_contracted4 =vpa_nonblocking2
            else:
                vazio = True

#            Transformando a implementação IOVPTS em contracted

            contracted_impl = Contracted(implementationIOVPTS)
            prods_impl, nok_impl, ok_impl = contracted_impl.getallprods()
            delta_impl = contracted_impl.genterminals(prods_impl)
            okleft_impl = contracted_impl.leftmost(prods_impl,delta_impl)
            okpairs_impl = contracted_impl.usefulpairs(okleft_impl)
            oktrans_impl,okstates_impl,okfinals_impl = contracted_impl.usefultrans(contracted_impl.trans, okpairs_impl)
            iovpts_contracted_impl = contracted_impl.save_iovpts_contracted()
            details.append(f"\nThe IOVPTS implementation is now contracted:\n")
            contracted_impl.save_contracted_info_to_list(details)

#            Transformando o IOVPTS contracted em VPA 

            transfmodel_impl = TransfModel(iovpts_contracted_impl)
            vpa_transfmodel_impl = transfmodel_impl.save_vpa_contracted(implementationIOVPTS)
            details.append(f"\nThe implementation is now a VPA from the contracted IOVPTS:\n")
            transfmodel_impl.save_vpa_from_iovpts_to_list(details)

#            Construção da intersecção entre o VPA de T e otr(I)
#            Obtaining the intersection between the models for T and otr(I).

            if vazio == False:
                intersecmodel3 = IntersecModel(vpa_contracted4, vpa_transfmodel_impl)
                intersecmodel3.compute_intersec()
                details.append(f"\nNow we obtain the VPA that accepts the intersection of T and otr(I):\n")
                intersecmodel3.save_intersec_info_to_list(details)

#            Simplificação do modelo resultante da intersecção de T e otr(I)

                iniciais3, estados3, finais3 = simplify.compute_estados(intersecmodel3, vpa_contracted4, vpa_transfmodel_impl)
                pilha3 = simplify.compute_pilha(intersecmodel3)
                novosiniciais3, novosestados3, novosfinais3, transicoes3, str_iniciais3, str_estados3, str_finais3, str_pilha3 = simplify.compute_transicoes(intersecmodel3, iniciais3, estados3, pilha3, finais3)
                vpa_simplify3 = simplify.save_intersec_vpa(intersecmodel3, str_iniciais3, str_estados3,transicoes3,str_finais3,str_pilha3)
                simplify.save_dictionaries_info_to_list(iniciais3, estados3, str_estados3, finais3, str_finais3, pilha3, str_pilha3, transicoes3, details)

#            Obtendo o VPA contracted para a intersecção do VPA de T e otr(I)
                intersecmodel3_iovpts = VPA2IOVPTS(vpa_simplify3,iovpts_contracted_impl)

#           Now we get a contracted VPA for T cap otr(I).
#           Transformando o VPA da intesercção entre T e I em contracted

                contracted5 = Contracted(intersecmodel3_iovpts)
                prods5, nok5, ok5 = contracted5.getallprods()
                delta5 = contracted5.genterminals(prods5)
                okleft5 = contracted5.leftmost(prods5,delta5)
                okpairs5 = contracted5.usefulpairs(okleft5)
                oktrans5,okstates5,okfinals5 = contracted5.usefultrans(contracted5.trans, okpairs5)
                vpa_contracted5 = contracted5.save_iovpts_contracted()
                details.append(f"\nThe simplified and contracted VPA for intersection of T and otr(I):\n")
                contracted5.save_contracted_info_to_list(details)

#            O VPA vpa_contracted5 é o resultado de T cap otr(I)

#            Verificação do balanced run sobre T cap otr(I) --> vpa_contracted5 

#           Renomeando os estados e transições do VPA resultante de T cap otr(I)
                vpa_renamed = Renaming(vpa_contracted5)
                str_states5, transitions5 = vpa_renamed.renaming()

#           Agora verificamos o balanced run sobre o VPA renomeado. 

                checker = BalancedRunChecker(vpa_contracted5.calls, vpa_contracted5.returns, vpa_contracted5.internals, vpa_contracted5.states, str_states5, transitions5, 0, len(str_states5)-1) #len(str_estados5) - 1)
                balanced_run, final_str = checker.check_balanced_run()

            else:
                final_str = ''

            if final_str == '':
                string=[]
            else:
                string = final_str.split(",")

            if string==['a2','@','@','b1'] or string==[]:
                print("                     There is no balanced run in the resulting VPA. ")
                print("                     So, the IUT conforms to the specification.")
                print("                     Therefore, ``the given IUT does vconf_{D,F} conform to the SPEC''.")

                st.info("The IUT conforms to the specification according to D and F languages.")
                details.append("\nVerdict: The IUT conforms to the specification according to D and F languages.\n")

            else:
                print("               There is a balanced run in the resulting VPA. ")
                print("               So, the IUT does not conform to the specification.")
                print("               Therefore, ``the given IUT does not vconf_{D,F} conform to the SPEC''.")
                print("                                                        ")
                print("                                                        ")
                print("               That is, below we give a test case that shows this condition.")
                print("                                                        ")
                result = []
                while string!=[]:
                    if string[0]=='a2' or string[0]=='@' or string[0]=='b1': 
                        del(string[0])
                    else: 
                        result.append(string[0])
                        del(string[0])
                print("                                                        ")
                print('            So',result,"is a run in the resulting VPA showing that the IUT does not conform to the specification using D and F languages.")

                print("                                                        ")
                print("                                                        ")
                print("                                                        ")

                st.info(f"The IUT does not conform to the specification according to D and F languages.")
                st.info(f"\nA test case that shows this condicton is: {result}\n")
                details.append(f"\nVerdict: The IUT does not conform to the specification according to D and F languages.\n")
                details.append(f"\nA test case that shows this condicton is: {result}\n")

            # Fim do tempo de processamento
            tempo_final = time.perf_counter()
            tempo_global = tempo_final - tempo_inicio
            tempo_total = round(tempo_global, 2)

            print("                                                        ")
            print("                     Processing time was:   ", tempo_total, " seconds")
            print("                                                        ")

            st.info(f"\nThe processing time was:    {tempo_total} seconds")
            details.append(f"\nThe processing time was:   {tempo_total} seconds\n")

            print(f"details: {details}")

            # Salvar detalhes em um arquivo de log na memória
            # buffer = io.BytesIO()
            # buffer.write("\n".join(details).encode('utf-8'))  # Write as binary (utf-8)
            # buffer.seek(0)  # Reset the buffer's position to the beginning
            
            import io

            # Função para garantir que todos os itens em details sejam strings
            def convert_to_string(item):
                if isinstance(item, list) or isinstance(item, dict):
                    return str(item)  # Converte listas e dicionários para strings
                return item  # Mantém os outros itens como estão

            # Converte cada item da lista para string se necessário
            details = [convert_to_string(item) for item in details]

            # Criação do buffer em memória
            buffer = io.BytesIO()

            # Escreve os detalhes no buffer, convertendo a lista em uma string separada por quebras de linha
            buffer.write("\n".join(details).encode('utf-8'))  # Escreve em binário (utf-8)

            # Posiciona o buffer de volta no início
            buffer.seek(0)

            # Remove .txt extension if it exists
            spec_name = specificationFile.name.lower().replace(" ", "_").replace(".txt", "")
            impl_name = implementationFile.name.lower().replace(" ", "_").replace(".txt", "")

            # Generate the filename
            # filename = f"Resultado.txt"
            filename = f"{spec_name}-{impl_name}.txt"
            # Exemplo de como salvar o buffer em um arquivo
            with open(filename, "wb") as f:
                f.write(buffer.getvalue())
                
            # Fornecer o botão de download
            st.download_button('Download Full Details', buffer, file_name=filename)